#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S2,     HTGYRO,              sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     HTIRS1,              sensorI2CCustom)
#pragma config(Sensor, S4,     HTIRS2,              sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorNormal, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorNormal, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     motorH,        tmotorNormal, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C4_2,     motorI,        tmotorNormal, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    servoA,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servoB,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    servoC,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    servoD,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    servoE,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_6,    servoF,               tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//This path will need to be changed depending on your include path.
#include "C:\Users\Max Chen\Desktop\452-rdpartyrobotcdr-v1.8.1-HT\rdpartyrobotcdr-v1.8.1-HT\drivers\common.h"
#include "C:\Users\Max Chen\Desktop\452-rdpartyrobotcdr-v1.8.1-HT\rdpartyrobotcdr-v1.8.1-HT\drivers\HTIRS2-driver.h"
#include "C:\Users\Max Chen\Desktop\452-rdpartyrobotcdr-v1.8.1-HT\rdpartyrobotcdr-v1.8.1-HT\drivers\HTGYRO-driver.h"
#include "C:\Users\Public\Documents\Robot C\Includes\auxilaryfunctions.h"


// IR variables
///////////////////////////////////////
// S4 is left IR and S3 is Right IR
const int median = 5;
int leftDirRead = 0;
int rightDirRead = 0;
int delta = 0;
const int scale = 20.5;// previously 12.5;
const int power = 50;
int leftDelta = 0;
int rightDelta = 0;
int motorPowerA  = 0;
int motorPowerB  = 0;
int IRinputs[3][6] = {{0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0}};// array for ir ports
int dc1S1, dc1S2, dc1S3, dc1S4, dc1S5 = 0; // IR port variables (dc1S1 refers to input 1 from the ir dcS2, #2; etc)
int dc2S1, dc2S2, dc2S3, dc2S4, dc2S5 = 0;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//IR
void UpdateIR() // brings back information from 1 port, which we can call w/ the variable IRport
{
 HTIRS2readAllDCStrength(HTIRS1, dc1S1, dc1S2, dc1S3, dc1S4, dc1S5);
 // ^^ reads ports
 IRinputs[1][1] = dc1S1; // sets ports to aray
 IRinputs[1][2] = dc1S2;
 IRinputs[1][3] = dc1S3;
 IRinputs[1][4] = dc1S4;
 IRinputs[1][5] = dc1S5;

 HTIRS2readAllDCStrength(HTIRS2, dc2S1, dc2S2, dc2S3, dc2S4, dc2S5);
 // ^^ reads ports
 IRinputs[2][1] = dc2S1; // sets ports to aray
 IRinputs[2][2] = dc2S2;
 IRinputs[2][3] = dc2S3;
 IRinputs[2][4] = dc2S4;
 IRinputs[2][5] = dc2S5;
}

void dualIR()
{
 //assign leftDirRead and rightDirRead to the high pin of their respective sensors
 leftDirRead = HTIRS2readDCDir(HTIRS1);
 rightDirRead = HTIRS2readDCDir(HTIRS2);

 leftDelta = leftDirRead - median;
 rightDelta = median - rightDirRead;

 delta = leftDelta - rightDelta;

 //for the left side of the robit.
 motorPowerA = -delta * scale + power;
 // for the right side of the robit.
 motorPowerB = delta * scale + power;

 if (leftDirRead == 0 || rightDirRead == 0) // failsafe
 {
   if (leftDirRead == 0 && rightDirRead == 0)
   {
     motor[motorE] = 25;
     motor[motorD] = 25;
   }
 }
 else if (delta == 0)
 {
   motor[motorE] = 100;
   motor[motorD] = 100;
 }
 else
 {
   motor[motorE] = motorPowerA;
   motor[motorD] = motorPowerB;
 }
 nxtDisplayTextLine(1, "%d", leftDirRead);
 nxtDisplayTextLine(2, "%d", rightDirRead);
}

void IRbeg()
{
 motor[motorE] = 50;
 motor[motorD] = 50;
 while(true)
 {
   UpdateIR();
   int high = 0;
   for (int m = 1; m < 3; m ++)
   {
     for (int n = 1; n < 6; n ++)
     {
       if (IRinputs[m][n] > high)
       {
         high = IRinputs[m][n];
       }
     }
   }
   if (high < 50) //previously 70 then 40 then
   {
     dualIR();
   }
   else
   {
     motor[motorE] = 0;
     motor[motorD] = 0;
   }
   //writeDebugStreamLine("%d", UpdateIR(1, highPort(1)));
   //writeDebugStreamLine("%d", UpdateIR(2, highPort(2)));
   wait1Msec(50);
 }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//END IR

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//TURN/GYRO
int deadband(int a, int threshold)
{
 if(abs(a) > threshold)
 {
    return a;
 }
 else
 {
    return 0;
 }
}

int initialize() // sets a zero point for the begining
{
int average = HTGYROstartCal(HTGYRO);
writeDebugStreamLine("average: %d", average);
return average;
}

void Turn(int power, long distance)
{
writeDebugStreamLine("new *****");
//writeDebugStreamLine("value: %d", SensorValue[Gyro]);
//int zero = initialize() + 59;//59 is added to perfectly 0 it.
long sum = 0;
//writeDebugStreamLine("delta: %d", SensorValue[Gyro] - zero);// begining delta is 59 +-1 often
//writeDebugStreamLine("zero: %d", zero);
//writeDebugStreamLine("value: %d", SensorValue[Gyro]);
//nMotorEncoder[motorB] = 0;
motor[motorD] = power;
motor[motorE] = -1 * power;
while( abs(sum) < abs(distance))// +-8400 is 90 degrees
{
   //writeDebugStreamLine("%d", SensorValue[Gyro] - zero);
   sum = sum + deadband(HTGYROreadRot(HTGYRO), 5);
   wait1Msec(10);// update interval
   writeDebugStreamLine("sum: %d", sum);
   writeDebugStreamLine("Gyro:   %4d", HTGYROreadRot(HTGYRO));
   nxtDisplayTextLine(4, "Gyro:   %4d", HTGYROreadRot(HTGYRO));
}
//writeDebugStreamLine("sum: %d", sum);
motor[motorD] = 0;
motor[motorE] = 0;
wait10Msec(1); // just to let the encoders reset when the robot is still
nMotorEncoder[motorE] = 0;
nMotorEncoder[motorD] = 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//END TURN/GYRO



///////////////////////////////////////////////////////////////////////////////////////////////
// This whole function is designed to move the robot a defined distance precicsly. It also converts iches to encoder counts.
void Move(int inDist, int power)
{
float EncoderCounts = (inDist - 1.9364)/0.0064; //This is all the data that Alec took last year put into an equation.
inDist = EncoderCounts; // Floats screw up all the things. so we used inDist but made it hold the encoder value.
//writeDebugStreamLine( "%d",inDist );
while(abs(nMotorEncoder[motorE]) < inDist && abs(nMotorEncoder[motorD]) < inDist)
{
 motor[motorE] = power;
 motor[motorD] = power;
}
motor[motorE] = 0;
motor[motorD] = 0;
wait10Msec(1); // just to let the encoders reset when the robot is still
nMotorEncoder[motorE] = 0;
nMotorEncoder[motorD] = 0;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//END MOVE


void PrimeAuto()
{
 Move(67,50); // dist,pow
 wait10Msec(10);
 initialize();
 Turn(-40, 9502); // going for 45 inside of left turn, overshoots // The direction of turn is determined only by altering power here, the sign of the distance has no effect because it is nulled during Abs() along with "sum" in the while statement
 wait10Msec(10);
 Move(36,50);
 wait10Msec(10);
 initialize();
 Turn(40,13031); //going for 20 inside of right turn // pow, angle
 wait10Msec(10);
 Move(28,50);
 wait10Msec(7);
 IRbeg();
}

task main()
{
 PrimeAuto();
    /*
 The current order of the functions is
 IR
 TURN
 MOVE
 From top down.
 */
}

